# 《语控未来城 (SmartCity)》智慧城市数字孪生系统设计文档

## 文档信息

| 项目名称 | 语控未来城 (SmartCity)                                                |
| -------- | --------------------------------------------------------------------- |
| 文档版本 | v1.0                                                                  |
| 编制日期 | 2026-01-30                                                            |
| 技术栈   | React + Vite + Ant Design + TailwindCSS + FastAPI + MySQL + Cesium.js |
| 目标用户 | 国内用户                                                              |

---

## 1. 系统概述

### 1.1 项目简介

本系统是一个基于AI的智慧城市数字孪生平台，通过自然语言控制3D城市场景，实现语义驱动的智慧城市管理。系统采用智谱AI GLM-4作为核心智能引擎，结合Cesium.js实现真实3D城市渲染。

### 1.2 核心特性

- **AI语义控制**: 通过GLM-4实现自然语言理解与3D场景联动
- **真实3D渲染**: 基于Cesium.js + OSM免费数据源实现真实城市3D模型
- **用户个性化**: 支持用户自定义AI模型、角色预设、执行策略
- **实时数据接入**: 集成高德地图、和风天气等免费API
- **安全认证**: 基于JWT的用户认证与权限管理系统

---

## 2. 技术架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         客户端层                              │
├─────────────────────────────────────────────────────────────┤
│  React 18 + Vite + Ant Design + TailwindCSS + Cesium.js    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │3D场景视图│  │AI对话面板│  │设置面板  │  │数据看板  │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                              ↕ HTTPS + JWT
┌─────────────────────────────────────────────────────────────┐
│                         API网关层                             │
├─────────────────────────────────────────────────────────────┤
│              FastAPI + CORS + 中间件 + 日志                  │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                       业务服务层                              │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │用户服务  │  │AI服务    │  │数据服务  │  │地图服务  │   │
│  │认证/授权 │  │GLM-4集成 │  │资产查询  │  │坐标转换  │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────┐
│                       数据存储层                              │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │MySQL 8.0 │  │Redis缓存 │  │本地文件  │  │外部API   │   │
│  │关系数据  │  │会话/热点 │  │3D模型    │  │高德/和风 │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术选型说明

#### 前端技术栈

| 技术          | 版本   | 用途       |
| ------------- | ------ | ---------- |
| React         | 18.x   | UI框架     |
| Vite          | 5.x    | 构建工具   |
| Ant Design    | 5.x    | UI组件库   |
| TailwindCSS   | 3.x    | CSS框架    |
| Cesium.js     | 1.110+ | 3D地图引擎 |
| Axios         | 1.x    | HTTP客户端 |
| Zustand/Jotai | 4.x    | 状态管理   |
| React Router  | 6.x    | 路由管理   |

#### 后端技术栈

| 技术        | 版本   | 用途           |
| ----------- | ------ | -------------- |
| Python      | 3.9+   | 开发语言       |
| FastAPI     | 0.104+ | Web框架        |
| SQLAlchemy  | 2.x    | ORM框架        |
| Pydantic    | 2.x    | 数据验证       |
| zhipuai     | 2.x    | 智谱AI SDK     |
| passlib     | 1.7+   | 密码加密       |
| python-jose | 3.3+   | JWT处理        |
| uvicorn     | 0.24+  | ASGI服务器     |
| aiohttp     | 3.x    | 异步HTTP客户端 |

#### 数据存储

| 技术  | 版本 | 用途             |
| ----- | ---- | ---------------- |
| MySQL | 8.0+ | 关系数据库       |
| Redis | 7.x  | 缓存数据库(可选) |

---

## 3. 数据库设计

### 3.1 数据库命名规范

- 所有表名前缀: `tb_`
- 所有主键名称: `id`
- 所有主键类型: `VARCHAR(36)` (UUID)
- 所有时间字段: `DATETIME`
- 所有删除标记: `is_deleted TINYINT(1) DEFAULT 0`
- 所有创建时间: `created_at DATETIME DEFAULT CURRENT_TIMESTAMP`
- 所有更新时间: `updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP`

### 3.2 核心数据表设计

#### 3.2.1 用户表 (tb_users)

```sql
CREATE TABLE tb_users (
    id VARCHAR(36) PRIMARY KEY COMMENT '用户ID (UUID)',
    username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
    email VARCHAR(100) UNIQUE NOT NULL COMMENT '邮箱',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    full_name VARCHAR(100) COMMENT '真实姓名',
    phone VARCHAR(20) COMMENT '手机号',
    avatar_url VARCHAR(500) COMMENT '头像URL',
    status TINYINT DEFAULT 1 COMMENT '状态: 0-禁用, 1-正常',
    is_deleted TINYINT(1) DEFAULT 0 COMMENT '是否删除',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

#### 3.2.2 用户配置表 (tb_user_configs)

```sql
CREATE TABLE tb_user_configs (
    id VARCHAR(36) PRIMARY KEY COMMENT '配置ID (UUID)',
    user_id VARCHAR(36) UNIQUE NOT NULL COMMENT '用户ID',
    provider VARCHAR(50) DEFAULT 'zhipu' COMMENT 'AI提供商: zhipu-智谱, qwen-通义, wenxin-文心, deepseek-深度, hunyuan-混元',
    model_name VARCHAR(50) DEFAULT 'glm-4-flash' COMMENT 'AI模型名称',
    persona VARCHAR(20) DEFAULT 'admin' COMMENT '角色: admin-管理员, planner-规划师, geek-极客',
    temperature DECIMAL(3,2) DEFAULT 0.7 COMMENT '温度参数 (0-1)',
    top_p DECIMAL(3,2) DEFAULT 0.9 COMMENT 'Top-P参数 (0-1)',
    auto_execute BOOLEAN DEFAULT FALSE COMMENT '是否自动执行指令',
    default_city VARCHAR(50) DEFAULT '北京' COMMENT '默认城市',
    language VARCHAR(10) DEFAULT 'zh-CN' COMMENT '语言',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (user_id) REFERENCES tb_users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户配置表';
```

#### 3.2.3 AI Provider配置表 (tb_ai_providers)

```sql
CREATE TABLE tb_ai_providers (
    id VARCHAR(36) PRIMARY KEY COMMENT '配置ID (UUID)',
    user_id VARCHAR(36) NOT NULL COMMENT '用户ID',
    provider_code VARCHAR(50) NOT NULL COMMENT '提供商代码: zhipu, qwen, wenxin, deepseek, hunyuan, openai',
    provider_name VARCHAR(100) NOT NULL COMMENT '提供商名称',
    api_key_encrypted TEXT COMMENT '加密的API Key',
    api_secret_encrypted TEXT COMMENT '加密的API Secret（部分提供商需要）',
    base_url VARCHAR(500) COMMENT '自定义API地址（可选）',
    is_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    is_default BOOLEAN DEFAULT FALSE COMMENT '是否为默认提供商',
    priority INT DEFAULT 0 COMMENT '优先级（数字越大优先级越高）',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (user_id) REFERENCES tb_users(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_provider (user_id, provider_code),
    INDEX idx_user_id (user_id),
    INDEX idx_provider_code (provider_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI提供商配置表';
```

#### 3.2.4 AI模型元数据表 (tb_ai_models)

```sql
CREATE TABLE tb_ai_models (
    id VARCHAR(36) PRIMARY KEY COMMENT '模型ID (UUID)',
    provider_code VARCHAR(50) NOT NULL COMMENT '提供商代码',
    model_code VARCHAR(100) NOT NULL COMMENT '模型代码',
    model_name VARCHAR(200) NOT NULL COMMENT '模型显示名称',
    description TEXT COMMENT '模型描述',
    context_length INT COMMENT '上下文长度',
    is_free BOOLEAN DEFAULT FALSE COMMENT '是否免费',
    input_price DECIMAL(10,4) COMMENT '输入价格（元/千tokens）',
    output_price DECIMAL(10,4) COMMENT '输出价格（元/千tokens）',
    supports_function_calling BOOLEAN DEFAULT FALSE COMMENT '是否支持Function Calling',
    supports_vision BOOLEAN DEFAULT FALSE COMMENT '是否支持视觉',
    max_tokens INT COMMENT '最大输出tokens',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否激活',
    display_order INT DEFAULT 0 COMMENT '显示顺序',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    UNIQUE KEY uk_provider_model (provider_code, model_code),
    INDEX idx_provider_code (provider_code),
    INDEX idx_is_free (is_free),
    INDEX idx_is_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI模型元数据表';
```

#### 3.2.5 用户使用统计表 (tb_ai_usage_stats)

```sql
CREATE TABLE tb_ai_usage_stats (
    id VARCHAR(36) PRIMARY KEY COMMENT '统计ID (UUID)',
    user_id VARCHAR(36) NOT NULL COMMENT '用户ID',
    provider_code VARCHAR(50) NOT NULL COMMENT '提供商代码',
    model_code VARCHAR(100) NOT NULL COMMENT '模型代码',
    date DATE NOT NULL COMMENT '统计日期',
    request_count INT DEFAULT 0 COMMENT '请求次数',
    input_tokens INT DEFAULT 0 COMMENT '输入tokens',
    output_tokens INT DEFAULT 0 COMMENT '输出tokens',
    total_tokens INT DEFAULT 0 COMMENT '总tokens',
    estimated_cost DECIMAL(10,4) DEFAULT 0 COMMENT '估算成本',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    FOREIGN KEY (user_id) REFERENCES tb_users(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_model_date (user_id, provider_code, model_code, date),
    INDEX idx_user_id (user_id),
    INDEX idx_date (date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI使用统计表';
```

#### 3.2.6 建筑资产表 (tb_buildings)

```sql
CREATE TABLE tb_buildings (
    id VARCHAR(36) PRIMARY KEY COMMENT '建筑ID (UUID)',
    name VARCHAR(200) NOT NULL COMMENT '建筑名称',
    category VARCHAR(50) COMMENT '类型: office-办公, landmark-地标, residential-住宅, commercial-商业',
    height DECIMAL(10,2) COMMENT '建筑高度(米)',
    longitude DECIMAL(11,8) NOT NULL COMMENT '经度 (WGS-84)',
    latitude DECIMAL(11,8) NOT NULL COMMENT '纬度 (WGS-84)',
    address VARCHAR(500) COMMENT '详细地址',
    district VARCHAR(100) COMMENT '所属区县',
    city VARCHAR(50) COMMENT '所属城市',
    status VARCHAR(20) DEFAULT 'normal' COMMENT '状态: normal-正常, abnormal-异常, high_risk-高风险',
    risk_level TINYINT DEFAULT 0 COMMENT '风险等级: 0-无, 1-低, 2-中, 3-高',
    floors INT COMMENT '楼层数',
    build_year INT COMMENT '建成年份',
    area DECIMAL(15,2) COMMENT '建筑面积(平方米)',
    description TEXT COMMENT '描述信息',
    is_deleted TINYINT(1) DEFAULT 0 COMMENT '是否删除',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    SPATIAL INDEX idx_location (longitude, latitude),
    INDEX idx_category (category),
    INDEX idx_status (status),
    INDEX idx_city_district (city, district),
    INDEX idx_height (height)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='建筑资产表';
```

#### 3.2.4 AI对话记录表 (tb_ai_conversations)

```sql
CREATE TABLE tb_ai_conversations (
    id VARCHAR(36) PRIMARY KEY COMMENT '对话ID (UUID)',
    user_id VARCHAR(36) NOT NULL COMMENT '用户ID',
    session_id VARCHAR(36) NOT NULL COMMENT '会话ID (UUID)',
    role VARCHAR(20) NOT NULL COMMENT '角色: user-用户, assistant-助手, system-系统',
    content TEXT NOT NULL COMMENT '对话内容',
    model_name VARCHAR(50) COMMENT '使用的模型',
    tokens_used INT COMMENT 'Token消耗量',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    FOREIGN KEY (user_id) REFERENCES tb_users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_session_id (session_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI对话记录表';
```

#### 3.2.5 操作日志表 (tb_operation_logs)

```sql
CREATE TABLE tb_operation_logs (
    id VARCHAR(36) PRIMARY KEY COMMENT '日志ID (UUID)',
    user_id VARCHAR(36) COMMENT '用户ID',
    operation_type VARCHAR(50) NOT NULL COMMENT '操作类型: fly_to, set_color, query_weather等',
    operation_data JSON COMMENT '操作数据(JSON格式)',
    ip_address VARCHAR(50) COMMENT 'IP地址',
    user_agent TEXT COMMENT '用户代理',
    status VARCHAR(20) DEFAULT 'success' COMMENT '状态: success-成功, failed-失败',
    error_message TEXT COMMENT '错误信息',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    FOREIGN KEY (user_id) REFERENCES tb_users(id) ON DELETE SET NULL,
    INDEX idx_user_id (user_id),
    INDEX idx_operation_type (operation_type),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='操作日志表';
```

#### 3.2.6 系统配置表 (tb_system_configs)

```sql
CREATE TABLE tb_system_configs (
    id VARCHAR(36) PRIMARY KEY COMMENT '配置ID (UUID)',
    config_key VARCHAR(100) UNIQUE NOT NULL COMMENT '配置键',
    config_value TEXT COMMENT '配置值',
    description VARCHAR(500) COMMENT '配置描述',
    is_public BOOLEAN DEFAULT FALSE COMMENT '是否公开(用户可见)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_config_key (config_key)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统配置表';
```

### 3.3 初始数据SQL

```sql
-- 插入系统默认配置
INSERT INTO tb_system_configs (id, config_key, config_value, description, is_public) VALUES
('1', 'default_model', 'glm-4-flash', '默认AI模型', TRUE),
('2', 'default_city', '北京', '默认城市', TRUE),
('3', 'max_tokens_per_request', '4000', '单次请求最大Token数', FALSE),
('4', 'conversation_history_limit', '20', '对话历史保留条数', TRUE);

-- 插入示例建筑数据 (北京市部分地标建筑)
INSERT INTO tb_buildings (id, name, category, height, longitude, latitude, address, district, city, status, floors) VALUES
('1', '中国尊', 'landmark', 528.0, 116.4347, 39.9087, '北京市朝阳区CBD核心区', '朝阳区', '北京', 'normal', 108),
('2', '国贸三期', 'office', 330.0, 116.4586, 39.9095, '北京市朝阳区建国门外大街1号', '朝阳区', '北京', 'normal', 74),
('3', '央视总部大楼', 'landmark', 234.0, 116.4732, 39.9129, '北京市朝阳区东三环中路32号', '朝阳区', '北京', 'normal', 52),
('4', '北京银泰中心', 'commercial', 249.9, 116.4561, 39.9072, '北京市朝阳区建国门外大街2号', '朝阳区', '北京', 'normal', 63),
('5', '中信大厦', 'office', 139.0, 116.4760, 39.9233, '北京市朝阳区光华路', '朝阳区', '北京', 'normal', 38);
```

---

## 4. 后端API设计

### 4.1 API规范

- 基础URL: `/api/v1`
- 认证方式: JWT Bearer Token
- 请求格式: `application/json`
- 响应格式: `application/json`
- 编码: `UTF-8`

#### 4.1.1 统一响应格式

```json
// 成功响应
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": "2026-01-30T12:00:00Z"
}

// 错误响应
{
  "code": 400,
  "message": "error message",
  "data": null,
  "timestamp": "2026-01-30T12:00:00Z"
}
```

### 4.2 认证授权API

#### 4.2.1 用户注册

```http
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123",
  "full_name": "测试用户"
}
```

**响应示例**:

```json
{
  "code": 200,
  "message": "注册成功",
  "data": {
    "user_id": "uuid-xxx-xxx",
    "username": "testuser",
    "email": "test@example.com"
  }
}
```

#### 4.2.2 用户登录

```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "username": "testuser",
  "password": "password123"
}
```

**响应示例**:

```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
    "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
    "token_type": "bearer",
    "expires_in": 86400,
    "user": {
      "id": "uuid-xxx-xxx",
      "username": "testuser",
      "email": "test@example.com",
      "full_name": "测试用户"
    }
  }
}
```

#### 4.2.3 刷新Token

```http
POST /api/v1/auth/refresh
Content-Type: application/json

{
  "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc..."
}
```

#### 4.2.4 用户登出

```http
POST /api/v1/auth/logout
Authorization: Bearer {access_token}
```

### 4.3 用户管理API

#### 4.3.1 获取当前用户信息

```http
GET /api/v1/users/me
Authorization: Bearer {access_token}
```

#### 4.3.2 更新用户信息

```http
PUT /api/v1/users/me
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "full_name": "新名字",
  "phone": "13800138000",
  "avatar_url": "https://..."
}
```

#### 4.3.3 修改密码

```http
PUT /api/v1/users/me/password
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "old_password": "oldpass",
  "new_password": "newpass"
}
```

### 4.4 用户配置API

#### 4.4.1 获取用户配置

```http
GET /api/v1/config
Authorization: Bearer {access_token}
```

**响应示例**:

```json
{
  "code": 200,
  "data": {
    "model_name": "glm-4-flash",
    "persona": "admin",
    "temperature": 0.7,
    "auto_execute": false,
    "default_city": "北京"
  }
}
```

#### 4.4.2 更新用户配置

```http
PUT /api/v1/config
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "model_name": "glm-4-plus",
  "persona": "planner",
  "temperature": 0.8,
  "auto_execute": true
}
```

### 4.5 AI对话API

#### 4.5.1 发送对话消息

```http
POST /api/v1/chat/completions
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "session_id": "uuid-session-id",
  "message": "分析一下朝阳区高度超过200米的建筑",
  "stream": false
}
```

**响应示例**:

```json
{
  "code": 200,
  "data": {
    "session_id": "uuid-session-id",
    "message": {
      "role": "assistant",
      "content": "已为您查询到朝阳区高度超过200米的建筑共3栋..."
    },
    "actions": [
      {
        "type": "fly_to",
        "params": {
          "longitude": 116.4347,
          "latitude": 39.9087,
          "height": 1000
        }
      },
      {
        "type": "highlight_buildings",
        "params": {
          "building_ids": ["1", "2", "3"],
          "color": "#ff0000"
        }
      }
    ],
    "tokens_used": 256
  }
}
```

#### 4.5.2 获取对话历史

```http
GET /api/v1/chat/history?session_id={session_id}&limit=20
Authorization: Bearer {access_token}
```

#### 4.5.3 清空对话历史

```http
DELETE /api/v1/chat/history/{session_id}
Authorization: Bearer {access_token}
```

### 4.6 建筑资产API

#### 4.6.1 查询建筑列表

```http
GET /api/v1/buildings?page=1&page_size=20&city=北京&category=landmark&min_height=100
Authorization: Bearer {access_token}
```

**响应示例**:

```json
{
  "code": 200,
  "data": {
    "total": 150,
    "page": 1,
    "page_size": 20,
    "items": [
      {
        "id": "1",
        "name": "中国尊",
        "category": "landmark",
        "height": 528.0,
        "longitude": 116.4347,
        "latitude": 39.9087,
        "status": "normal"
      }
    ]
  }
}
```

#### 4.6.2 获取建筑详情

```http
GET /api/v1/buildings/{building_id}
Authorization: Bearer {access_token}
```

#### 4.6.3 空间查询-圆形范围

```http
POST /api/v1/buildings/spatial/circle
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "center": {
    "longitude": 116.4347,
    "latitude": 39.9087
  },
  "radius": 1000,
  "filters": {
    "min_height": 100
  }
}
```

#### 4.6.4 更新建筑状态

```http
PUT /api/v1/buildings/{building_id}/status
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "status": "high_risk",
  "risk_level": 3
}
```

### 4.7 地图与位置服务API

#### 4.7.1 坐标转换 (GCJ-02转WGS-84)

```http
POST /api/v1/map/coordinate/convert
Authorization: Bearer {access_token}
Content-Type: application/json

{
  "coordinates": [
    {"longitude": 116.4347, "latitude": 39.9087}
  ],
  "from": "gcj02",
  "to": "wgs84"
}
```

#### 4.7.2 获取天气信息

```http
GET /api/v1/weather?city=北京
Authorization: Bearer {access_token}
```

**响应示例**:

```json
{
  "code": 200,
  "data": {
    "city": "北京",
    "temperature": 25,
    "weather": "晴",
    "humidity": 45,
    "wind_speed": 3.5,
    "update_time": "2026-01-30T12:00:00Z"
  }
}
```

#### 4.7.3 获取POI搜索建议

```http
GET /api/v1/map/poi/search?keyword=中国尊&city=北京
Authorization: Bearer {access_token}
```

### 4.8 系统配置API

#### 4.8.1 获取系统配置

```http
GET /api/v1/system/config
```

**响应示例**:

```json
{
  "code": 200,
  "data": {
    "default_model": "glm-4-flash",
    "default_city": "北京",
    "max_tokens_per_request": 4000,
    "available_models": [
      {
        "name": "glm-4-flash",
        "display_name": "GLM-4 Flash (免费)",
        "max_tokens": 128000,
        "is_free": true
      },
      {
        "name": "glm-4-plus",
        "display_name": "GLM-4 Plus",
        "max_tokens": 128000,
        "is_free": false
      }
    ]
  }
}
```

---

## 5. 前端设计

### 5.1 页面结构

```
src/
├── App.tsx                    # 根组件
├── main.tsx                   # 入口文件
├── index.css                  # 全局样式
├── assets/                    # 静态资源
├── components/                # 公共组件
│   ├── CesiumViewer/          # Cesium 3D查看器
│   ├── AIChatPanel/           # AI对话面板
│   ├── ConfigPanel/           # 设置面板
│   ├── DataDashboard/         # 数据看板
│   ├── BuildingCard/          # 建筑卡片
│   └── AuthModal/             # 登录注册弹窗
├── pages/                     # 页面
│   ├── HomePage/              # 主页
│   ├── LoginPage/             # 登录页
│   └── RegisterPage/          # 注册页
├── layouts/                   # 布局组件
│   └── MainLayout/            # 主布局
├── hooks/                     # 自定义Hooks
│   ├── useAuth.ts             # 认证Hook
│   ├── useCesium.ts           # Cesium Hook
│   ├── useAIChat.ts           # AI对话Hook
│   └── useBuildingData.ts     # 建筑数据Hook
├── services/                  # API服务
│   ├── api.ts                 # API客户端
│   ├── auth.ts                # 认证API
│   ├── chat.ts                # 对话API
│   ├── building.ts            # 建筑API
│   └── map.ts                 # 地图API
├── stores/                    # 状态管理
│   ├── authStore.ts           # 认证状态
│   ├── configStore.ts         # 配置状态
│   └── chatStore.ts           # 对话状态
├── types/                     # TypeScript类型
│   ├── auth.ts                # 认证类型
│   ├── building.ts            # 建筑类型
│   ├── chat.ts                # 对话类型
│   └── config.ts              # 配置类型
├── utils/                     # 工具函数
│   ├── cesiumHelper.ts        # Cesium辅助函数
│   ├── coordinate.ts          # 坐标转换
│   └── request.ts             # 请求封装
└── router/                    # 路由配置
    └── index.tsx
```

### 5.2 核心组件设计

#### 5.2.1 CesiumViewer 组件

```typescript
interface CesiumViewerProps {
  onBuildingClick?: (building: Building) => void;
  onCameraChange?: (position: CameraPosition) => void;
  weather?: WeatherData;
}

// 功能:
// - 初始化Cesium地球
// - 加载OSM 3D建筑物
// - 加载高德地图底图
// - 实现建筑物高亮、飞行等动画
// - 响应AI指令更新场景
```

#### 5.2.2 AIChatPanel 组件

```typescript
interface AIChatPanelProps {
  onActionGenerated?: (actions: AIAction[]) => void;
}

// 功能:
// - 显示对话历史
// - 输入消息
// - 显示AI思考过程
// - 显示执行的动作卡片
// - 支持审核模式下的确认对话框
```

#### 5.2.3 ConfigPanel 组件

```typescript
// 功能:
// - AI模型选择
// - 角色预设切换
// - 参数调节 (Temperature, Top-P)
// - 自定义API Key输入
// - 执行策略切换
// - 默认城市设置
```

#### 5.2.4 DataDashboard 组件

```typescript
// 功能:
// - 显示选中建筑详细信息
// - 显示区域建筑统计
// - 显示天气信息
// - 显示空间分析结果
```

### 5.3 路由设计

```typescript
const routes = [
  {
    path: '/',
    element: <MainLayout />,
    children: [
      {
        index: true,
        element: <HomePage />
      }
    ]
  },
  {
    path: '/login',
    element: <LoginPage />
  },
  {
    path: '/register',
    element: <RegisterPage />
  }
];
```

### 5.4 状态管理方案

使用 Zustand 进行轻量级状态管理:

```typescript
// stores/authStore.ts
interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
  updateUser: (user: Partial<User>) => void;
}

// stores/configStore.ts
interface ConfigState {
  config: UserConfig;
  updateConfig: (config: Partial<UserConfig>) => void;
  resetConfig: () => void;
}

// stores/chatStore.ts
interface ChatState {
  sessions: ChatSession[];
  currentSessionId: string | null;
  messages: Message[];
  addMessage: (message: Message) => void;
  clearSession: (sessionId: string) => void;
}
```

---

## 6. 多AI Provider架构设计

### 6.1 设计目标

支持用户自主选择和配置多个AI大模型提供商，实现：
- **灵活性**：用户可以自由切换不同的AI模型
- **可扩展性**：轻松添加新的AI提供商
- **统一性**：统一的调用接口，屏蔽底层差异
- **成本优化**：支持免费模型和付费模型混合使用
- **透明性**：清晰的使用统计和成本追踪

### 6.2 支持的AI Provider

#### 6.2.1 国内主流AI模型

| Provider | 代码 | 免费模型 | 特色 | OpenAI兼容 |
|----------|------|----------|------|-------------|
| **智谱AI** | `zhipu` | GLM-4-Flash | 上下文128K，中文理解强 | ✅ |
| **通义千问** | `qwen` | Qwen-Turbo | 阿里云生态，长文本 | ✅ |
| **文心一言** | `wenxin` | ERNIE-Speed | 百度知识图谱 | ❌ |
| **DeepSeek** | `deepseek` | DeepSeek-Chat | 性价比高，代码能力强 | ✅ |
| **腾讯混元** | `hunyuan` | hunyuan-lite | 微信生态集成 | ❌ |
| **讯飞星火** | `spark` | Spark-Lite | 语音能力强 | ❌ |

#### 6.2.2 国际AI模型（可选）

| Provider | 代码 | 免费模型 | 特色 | OpenAI兼容 |
|----------|------|----------|------|-------------|
| **OpenAI** | `openai` | gpt-4o-mini | 最强综合能力 | ✅ |
| **Anthropic** | `anthropic` | - | 长上下文，安全性强 | ❌ |
| **Google** | `google` | gemini-flash | 多模态能力强 | ✅ |

### 6.3 架构设计

#### 6.3.1 分层架构

```
┌─────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)              │
│  - 用户配置界面                                            │
│  - 模型选择界面                                            │
│  - 使用统计看板                                            │
└─────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────┐
│                  抽象层 (Abstraction Layer)                │
│  ┌──────────────────────────────────────────────────┐   │
│  │         AIProviderFactory (工厂模式)               │   │
│  │  - 创建Provider实例                                │   │
│  │  - 管理Provider生命周期                            │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │         BaseAIProvider (抽象基类)                  │   │
│  │  + chat_completion()                              │   │
│  │  + stream_chat()                                  │   │
│  │  + embed_text()                                   │   │
│  │  + count_tokens()                                 │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────┐
│                   实现层 (Implementation Layer)             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │ZhipuAI   │  │QwenAI    │  │DeepSeekAI│  │OpenAI    ││
│  │Provider  │  │Provider  │  │Provider  │  │Provider  ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
│  ┌──────────┐  ┌──────────┐  ┌──────────┐               │
│  │WenxinAI  │  │HunyuanAI │  │SparkAI   │               │
│  │Provider  │  │Provider  │  │Provider  │               │
│  └──────────┘  └──────────┘  └──────────┘               │
└─────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────┐
│                   第三方API层 (External APIs)               │
│  - 智谱AI API                                            │
│  - 通义千问 API                                           │
│  - DeepSeek API                                          │
│  - ...                                                   │
└─────────────────────────────────────────────────────────┘
```

#### 6.3.2 抽象基类设计

```python
# app/services/ai/base.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, AsyncIterator
from dataclasses import dataclass

@dataclass
class Message:
    """消息数据类"""
    role: str  # system, user, assistant
    content: str

@dataclass
class ChatCompletionResponse:
    """聊天响应数据类"""
    content: str
    model: str
    tokens_used: Dict[str, int]  # {input_tokens, output_tokens, total_tokens}
    finish_reason: str
    tool_calls: List[Dict[str, Any]] = None

@dataclass
class ModelInfo:
    """模型信息"""
    code: str
    name: str
    description: str
    context_length: int
    is_free: bool
    input_price: float
    output_price: float
    supports_function_calling: bool
    supports_vision: bool
    max_tokens: int

class BaseAIProvider(ABC):
    """AI Provider抽象基类"""

    def __init__(
        self,
        api_key: str,
        base_url: Optional[str] = None,
        **kwargs
    ):
        self.api_key = api_key
        self.base_url = base_url or self.default_base_url
        self.client = self._init_client()

    @property
    @abstractmethod
    def provider_code(self) -> str:
        """提供商代码"""
        pass

    @property
    @abstractmethod
    def provider_name(self) -> str:
        """提供商名称"""
        pass

    @property
    @abstractmethod
    def default_base_url(self) -> str:
        """默认API地址"""
        pass

    @abstractmethod
    def _init_client(self):
        """初始化客户端"""
        pass

    @abstractmethod
    async def chat_completion(
        self,
        messages: List[Message],
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 2000,
        tools: List[Dict[str, Any]] = None,
        **kwargs
    ) -> ChatCompletionResponse:
        """聊天补全"""
        pass

    @abstractmethod
    async def stream_chat_completion(
        self,
        messages: List[Message],
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 2000,
        **kwargs
    ) -> AsyncIterator[str]:
        """流式聊天补全"""
        pass

    async def count_tokens(
        self,
        messages: List[Message],
        model: str
    ) -> int:
        """计算tokens（可选实现）"""
        # 默认实现：粗略估算（中文1字符≈2tokens）
        text = "\n".join([msg.content for msg in messages])
        return len(text) * 2

    async def embed_text(
        self,
        text: str,
        model: str
    ) -> List[float]:
        """文本嵌入（可选实现）"""
        raise NotImplementedError("Embedding not supported")

    async def list_models(self) -> List[ModelInfo]:
        """列出可用模型"""
        raise NotImplementedError("Model listing not supported")
```

#### 6.3.3 具体Provider实现

**智谱AI Provider (OpenAI兼容)**:

```python
# app/services/ai/providers/zhipu.py
from openai import AsyncOpenAI
from ..base import BaseAIProvider, ChatCompletionResponse, Message, ModelInfo

class ZhipuAIProvider(BaseAIProvider):
    """智谱AI Provider"""

    @property
    def provider_code(self) -> str:
        return "zhipu"

    @property
    def provider_name(self) -> str:
        return "智谱AI"

    @property
    def default_base_url(self) -> str:
        return "https://open.bigmodel.cn/api/paas/v4"

    def _init_client(self):
        return AsyncOpenAI(
            api_key=self.api_key,
            base_url=self.base_url
        )

    async def chat_completion(
        self,
        messages: List[Message],
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 2000,
        tools: List[Dict[str, Any]] = None,
        **kwargs
    ) -> ChatCompletionResponse:
        # 转换消息格式
        api_messages = [
            {"role": msg.role, "content": msg.content}
            for msg in messages
        ]

        # 调用API
        response = await self.client.chat.completions.create(
            model=model,
            messages=api_messages,
            temperature=temperature,
            max_tokens=max_tokens,
            tools=tools,
            **kwargs
        )

        # 解析响应
        choice = response.choices[0]
        tool_calls = []
        if choice.message.tool_calls:
            tool_calls = [
                {
                    "id": tc.id,
                    "type": tc.type,
                    "function": {
                        "name": tc.function.name,
                        "arguments": tc.function.arguments
                    }
                }
                for tc in choice.message.tool_calls
            ]

        return ChatCompletionResponse(
            content=choice.message.content or "",
            model=response.model,
            tokens_used={
                "input_tokens": response.usage.prompt_tokens,
                "output_tokens": response.usage.completion_tokens,
                "total_tokens": response.usage.total_tokens
            },
            finish_reason=choice.finish_reason,
            tool_calls=tool_calls if tool_calls else None
        )

    async def stream_chat_completion(
        self,
        messages: List[Message],
        model: str,
        temperature: float = 0.7,
        max_tokens: int = 2000,
        **kwargs
    ):
        """流式聊天"""
        api_messages = [
            {"role": msg.role, "content": msg.content}
            for msg in messages
        ]

        stream = await self.client.chat.completions.create(
            model=model,
            messages=api_messages,
            temperature=temperature,
            max_tokens=max_tokens,
            stream=True,
            **kwargs
        )

        async for chunk in stream:
            if chunk.choices[0].delta.content:
                yield chunk.choices[0].delta.content

    async def list_models(self) -> List[ModelInfo]:
        """列出智谱AI可用模型"""
        return [
            ModelInfo(
                code="glm-4-flash",
                name="GLM-4 Flash",
                description="智谱AI免费模型，快速响应",
                context_length=128000,
                is_free=True,
                input_price=0,
                output_price=0,
                supports_function_calling=True,
                supports_vision=False,
                max_tokens=8000
            ),
            ModelInfo(
                code="glm-4-plus",
                name="GLM-4 Plus",
                description="智谱AI增强模型，深度推理",
                context_length=128000,
                is_free=False,
                input_price=0.01,
                output_price=0.01,
                supports_function_calling=True,
                supports_vision=True,
                max_tokens=8000
            ),
            ModelInfo(
                code="glm-4-air",
                name="GLM-4 Air",
                description="智谱AI轻量模型",
                context_length=128000,
                is_free=False,
                input_price=0.001,
                output_price=0.001,
                supports_function_calling=True,
                supports_vision=False,
                max_tokens=8000
            )
        ]
```

**通义千问 Provider (OpenAI兼容)**:

```python
# app/services/ai/providers/qwen.py
class QwenAIProvider(BaseAIProvider):
    """通义千问 Provider"""

    @property
    def provider_code(self) -> str:
        return "qwen"

    @property
    def provider_name(self) -> str:
        return "通义千问"

    @property
    def default_base_url(self) -> str:
        return "https://dashscope.aliyuncs.com/compatible-mode/v1"

    def _init_client(self):
        return AsyncOpenAI(
            api_key=self.api_key,
            base_url=self.base_url
        )

    # 实现与ZhipuAIProvider类似的方法...
```

#### 6.3.4 Provider工厂

```python
# app/services/ai/factory.py
from typing import Dict, Type
from ..base import BaseAIProvider
from ..providers.zhipu import ZhipuAIProvider
from ..providers.qwen import QwenAIProvider
from ..providers.deepseek import DeepSeekAIProvider

class AIProviderFactory:
    """AI Provider工厂"""

    _providers: Dict[str, Type[BaseAIProvider]] = {
        "zhipu": ZhipuAIProvider,
        "qwen": QwenAIProvider,
        "deepseek": DeepSeekAIProvider,
        # 添加更多Provider...
    }

    @classmethod
    def register_provider(cls, code: str, provider_class: Type[BaseAIProvider]):
        """注册新的Provider"""
        cls._providers[code] = provider_class

    @classmethod
    def create_provider(
        cls,
        provider_code: str,
        api_key: str,
        base_url: str = None,
        **kwargs
    ) -> BaseAIProvider:
        """创建Provider实例"""
        provider_class = cls._providers.get(provider_code)

        if not provider_class:
            raise ValueError(f"Unsupported provider: {provider_code}")

        return provider_class(
            api_key=api_key,
            base_url=base_url,
            **kwargs
        )

    @classmethod
    def list_supported_providers(cls) -> List[str]:
        """列出支持的Provider"""
        return list(cls._providers.keys())
```

#### 6.3.5 服务层封装

```python
# app/services/ai_service.py
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.ai_providers import AIProvider
from app.models.ai_models import AIModel
from app.services.ai.factory import AIProviderFactory
from app.services.ai.base import BaseAIProvider, Message, ChatCompletionResponse

class AIService:
    """AI服务统一入口"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_user_default_provider(
        self,
        user_id: str
    ) -> BaseAIProvider:
        """获取用户的默认AI Provider"""
        # 查询用户配置的默认Provider
        result = await self.db.execute(
            select(AIProvider)
            .where(
                AIProvider.user_id == user_id,
                AIProvider.is_enabled == True,
                AIProvider.is_default == True
            )
        )
        provider_config = result.scalar_one_or_none()

        if not provider_config:
            # 如果没有设置默认，返回第一个启用的
            result = await self.db.execute(
                select(AIProvider)
                .where(
                    AIProvider.user_id == user_id,
                    AIProvider.is_enabled == True
                )
                .order_by(AIProvider.priority.desc())
                .limit(1)
            )
            provider_config = result.scalar_one_or_none()

        if not provider_config:
            raise ValueError("No enabled AI provider found")

        # 创建Provider实例
        return AIProviderFactory.create_provider(
            provider_code=provider_config.provider_code,
            api_key=self._decrypt_api_key(provider_config.api_key_encrypted),
            base_url=provider_config.base_url
        )

    async def chat_completion(
        self,
        user_id: str,
        messages: List[Message],
        model: str = None,
        temperature: float = 0.7,
        tools: List[Dict] = None,
        **kwargs
    ) -> ChatCompletionResponse:
        """聊天补全（自动选择Provider）"""
        provider = await self.get_user_default_provider(user_id)

        # 如果未指定模型，使用Provider的默认模型
        if not model:
            model = await self._get_default_model(user_id, provider.provider_code)

        # 调用Provider
        response = await provider.chat_completion(
            messages=messages,
            model=model,
            temperature=temperature,
            tools=tools,
            **kwargs
        )

        # 记录使用统计
        await self._record_usage(
            user_id=user_id,
            provider_code=provider.provider_code,
            model_code=model,
            tokens_used=response.tokens_used
        )

        return response

    async def list_available_models(
        self,
        user_id: str,
        provider_code: str = None
    ) -> List[ModelInfo]:
        """列出用户可用的模型"""
        # 获取用户启用的Providers
        result = await self.db.execute(
            select(AIProvider)
            .where(
                AIProvider.user_id == user_id,
                AIProvider.is_enabled == True
            )
        )
        user_providers = result.scalars().all()

        if not user_providers:
            # 返回系统默认的免费模型
            return await self._get_free_models()

        models = []
        for provider_config in user_providers:
            if provider_code and provider_config.provider_code != provider_code:
                continue

            provider = AIProviderFactory.create_provider(
                provider_code=provider_config.provider_code,
                api_key=self._decrypt_api_key(provider_config.api_key_encrypted)
            )

            provider_models = await provider.list_models()
            models.extend(provider_models)

        return models

    def _decrypt_api_key(self, encrypted_key: str) -> str:
        """解密API Key"""
        from app.core.security import decrypt_api_key
        return decrypt_api_key(encrypted_key)

    async def _record_usage(
        self,
        user_id: str,
        provider_code: str,
        model_code: str,
        tokens_used: Dict[str, int]
    ):
        """记录使用统计"""
        from app.models.ai_usage_stats import AIUsageStats
        from datetime import date
        from sqlalchemy.dialects.mysql import insert

        # 使用UPSERT更新统计
        stmt = insert(AIUsageStats).values(
            user_id=user_id,
            provider_code=provider_code,
            model_code=model_code,
            date=date.today(),
            request_count=1,
            input_tokens=tokens_used.get("input_tokens", 0),
            output_tokens=tokens_used.get("output_tokens", 0),
            total_tokens=tokens_used.get("total_tokens", 0)
        )
        stmt = stmt.on_duplicate_key_update(
            request_count=AIUsageStats.request_count + 1,
            input_tokens=AIUsageStats.input_tokens + stmt.inserted.input_tokens,
            output_tokens=AIUsageStats.output_tokens + stmt.inserted.output_tokens,
            total_tokens=AIUsageStats.total_tokens + stmt.inserted.total_tokens
        )

        await self.db.execute(stmt)
        await self.db.commit()
```

### 6.4 前端配置界面

#### 6.4.1 AI Provider配置组件

```typescript
// src/components/AIProviderConfig.tsx
import { useState, useEffect } from 'react';
import { Card, Form, Input, Select, Button, Switch, Space, message } from 'antd';
import { PlusOutlined, DeleteOutlined } from '@ant-design/icons';

interface Provider {
  id: string;
  provider_code: string;
  provider_name: string;
  api_key_encrypted: string;
  is_enabled: boolean;
  is_default: boolean;
}

export const AIProviderConfig: React.FC = () => {
  const [form] = Form.useForm();
  const [providers, setProviders] = useState<Provider[]>([]);
  const [loading, setLoading] = useState(false);

  // 加载用户配置的Providers
  useEffect(() => {
    loadProviders();
  }, []);

  const loadProviders = async () => {
    setLoading(true);
    try {
      const res = await api.getAIProviders();
      setProviders(res.data);
    } catch (error) {
      message.error('加载AI提供商失败');
    } finally {
      setLoading(false);
    }
  };

  // 添加新Provider
  const handleAddProvider = async (values: any) => {
    try {
      await api.addAIProvider({
        provider_code: values.provider_code,
        api_key: values.api_key,
        base_url: values.base_url,
      });
      message.success('添加成功');
      loadProviders();
      form.resetFields();
    } catch (error) {
      message.error('添加失败');
    }
  };

  // 设置默认Provider
  const handleSetDefault = async (providerId: string) => {
    try {
      await api.setDefaultProvider(providerId);
      message.success('设置成功');
      loadProviders();
    } catch (error) {
      message.error('设置失败');
    }
  };

  // 删除Provider
  const handleDelete = async (providerId: string) => {
    try {
      await api.deleteAIProvider(providerId);
      message.success('删除成功');
      loadProviders();
    } catch (error) {
      message.error('删除失败');
    }
  };

  return (
    <div className="ai-provider-config">
      <Card title="添加AI提供商" style={{ marginBottom: 16 }}>
        <Form
          form={form}
          layout="inline"
          onFinish={handleAddProvider}
        >
          <Form.Item
            name="provider_code"
            label="AI提供商"
            rules={[{ required: true }]}
          >
            <Select style={{ width: 200 }}>
              <Select.Option value="zhipu">智谱AI</Select.Option>
              <Select.Option value="qwen">通义千问</Select.Option>
              <Select.Option value="deepseek">DeepSeek</Select.Option>
              <Select.Option value="wenxin">文心一言</Select.Option>
              <Select.Option value="hunyuan">腾讯混元</Select.Option>
              <Select.Option value="openai">OpenAI</Select.Option>
            </Select>
          </Form.Item>

          <Form.Item
            name="api_key"
            label="API Key"
            rules={[{ required: true }]}
          >
            <Input.Password placeholder="请输入API Key" style={{ width: 300 }} />
          </Form.Item>

          <Form.Item name="base_url" label="API地址（可选）">
            <Input placeholder="默认使用官方地址" style={{ width: 250 }} />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" icon={<PlusOutlined />}>
              添加
            </Button>
          </Form.Item>
        </Form>
      </Card>

      <Card title="已配置的AI提供商">
        <List
          loading={loading}
          dataSource={providers}
          renderItem={(provider) => (
            <List.Item
              actions={[
                <Button
                  type="link"
                  disabled={provider.is_default}
                  onClick={() => handleSetDefault(provider.id)}
                >
                  {provider.is_default ? '默认' : '设为默认'}
                </Button>,
                <Button
                  type="link"
                  danger
                  icon={<DeleteOutlined />}
                  onClick={() => handleDelete(provider.id)}
                >
                  删除
                </Button>
              ]}
            >
              <List.Item.Meta
                title={provider.provider_name}
                description={`API Key: ****${provider.api_key_encrypted.slice(-4)}`}
              />
              <Switch
                checked={provider.is_enabled}
                onChange={(checked) => handleToggleProvider(provider.id, checked)}
                checkedChildren="启用"
                unCheckedChildren="禁用"
              />
            </List.Item>
          )}
        />
      </Card>
    </div>
  );
};
```

#### 6.4.2 模型选择组件

```typescript
// src/components/ModelSelector.tsx
export const ModelSelector: React.FC = () => {
  const [models, setModels] = useState<ModelInfo[]>([]);
  const [selectedModel, setSelectedModel] = useState<string>('');

  useEffect(() => {
    loadAvailableModels();
  }, []);

  const loadAvailableModels = async () => {
    const res = await api.listAvailableModels();
    setModels(res.data);
  };

  return (
    <Select
      value={selectedModel}
      onChange={setSelectedModel}
      style={{ width: '100%' }}
      placeholder="选择AI模型"
    >
      {models.map((model) => (
        <Select.Option key={model.code} value={model.code}>
          <Space>
            <span>{model.name}</span>
            {model.is_free && (
              <Tag color="green">免费</Tag>
            )}
            <span className="text-gray-400">
              ¥{model.input_price}/{model.output_price} per 1K tokens
            </span>
          </Space>
        </Select.Option>
      ))}
    </Select>
  );
};
```

### 6.5 API设计

#### 6.5.1 Provider管理API

```python
# app/api/v1/ai_providers.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.deps import get_current_user, get_db
from app.schemas.ai_provider import (
    AIProviderCreate,
    AIProviderResponse,
    AIProviderUpdate
)

router = APIRouter()

@router.get("/ai/providers", response_model=List[AIProviderResponse])
async def list_providers(
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """获取用户配置的AI Providers"""
    result = await db.execute(
        select(AIProvider).where(AIProvider.user_id == current_user.id)
    )
    return result.scalars().all()

@router.post("/ai/providers", response_model=AIProviderResponse)
async def add_provider(
    provider_data: AIProviderCreate,
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """添加新的AI Provider"""
    # 加密API Key
    from app.core.security import encrypt_api_key
    encrypted_key = encrypt_api_key(provider_data.api_key)

    new_provider = AIProvider(
        user_id=current_user.id,
        provider_code=provider_data.provider_code,
        provider_name=provider_data.provider_name,
        api_key_encrypted=encrypted_key,
        base_url=provider_data.base_url,
        is_enabled=True
    )

    db.add(new_provider)
    await db.commit()
    await db.refresh(new_provider)

    return new_provider

@router.put("/ai/providers/{provider_id}/default")
async def set_default_provider(
    provider_id: str,
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """设置默认Provider"""
    # 取消其他Provider的默认状态
    await db.execute(
        update(AIProvider)
        .where(AIProvider.user_id == current_user.id)
        .values(is_default=False)
    )

    # 设置新的默认Provider
    await db.execute(
        update(AIProvider)
        .where(
            AIProvider.id == provider_id,
            AIProvider.user_id == current_user.id
        )
        .values(is_default=True)
    )

    await db.commit()
    return {"message": "设置成功"}

@router.delete("/ai/providers/{provider_id}")
async def delete_provider(
    provider_id: str,
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """删除AI Provider"""
    result = await db.execute(
        delete(AIProvider)
        .where(
            AIProvider.id == provider_id,
            AIProvider.user_id == current_user.id
        )
    )
    await db.commit()

    if result.rowcount == 0:
        raise HTTPException(status_code=404, detail="Provider not found")

    return {"message": "删除成功"}
```

#### 6.5.2 模型查询API

```python
@router.get("/ai/models", response_model=List[ModelInfoResponse])
async def list_models(
    provider_code: Optional[str] = None,
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """列出可用模型"""
    ai_service = AIService(db)
    models = await ai_service.list_available_models(
        user_id=current_user.id,
        provider_code=provider_code
    )
    return models
```

#### 6.5.3 使用统计API

```python
@router.get("/ai/usage/stats")
async def get_usage_stats(
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    current_user = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """获取AI使用统计"""
    query = select(AIUsageStats).where(AIUsageStats.user_id == current_user.id)

    if start_date:
        query = query.where(AIUsageStats.date >= start_date)
    if end_date:
        query = query.where(AIUsageStats.date <= end_date)

    result = await db.execute(query)
    stats = result.scalars().all()

    # 汇总统计
    summary = {
        "total_requests": sum(s.request_count for s in stats),
        "total_tokens": sum(s.total_tokens for s in stats),
        "total_cost": sum(s.estimated_cost for s in stats),
        "by_provider": {},
        "by_model": {},
        "daily_stats": []
    }

    for stat in stats:
        # 按Provider统计
        if stat.provider_code not in summary["by_provider"]:
            summary["by_provider"][stat.provider_code] = {
                "tokens": 0,
                "cost": 0
            }
        summary["by_provider"][stat.provider_code]["tokens"] += stat.total_tokens
        summary["by_provider"][stat.provider_code]["cost"] += stat.estimated_cost

        # 按模型统计
        model_key = f"{stat.provider_code}/{stat.model_code}"
        if model_key not in summary["by_model"]:
            summary["by_model"][model_key] = {
                "tokens": 0,
                "cost": 0
            }
        summary["by_model"][model_key]["tokens"] += stat.total_tokens
        summary["by_model"][model_key]["cost"] += stat.estimated_cost

    return summary
```

### 6.6 初始化数据

```sql
-- 插入AI模型元数据（系统预置）
INSERT INTO tb_ai_models (id, provider_code, model_code, model_name, description, context_length, is_free, input_price, output_price, supports_function_calling, supports_vision, max_tokens, is_active, display_order) VALUES
-- 智谱AI
('1', 'zhipu', 'glm-4-flash', 'GLM-4 Flash', '智谱AI免费模型，快速响应', 128000, TRUE, 0.0000, 0.0000, TRUE, FALSE, 8000, TRUE, 1),
('2', 'zhipu', 'glm-4-plus', 'GLM-4 Plus', '智谱AI增强模型，深度推理', 128000, FALSE, 0.0100, 0.0100, TRUE, TRUE, 8000, TRUE, 2),
('3', 'zhipu', 'glm-4-air', 'GLM-4 Air', '智谱AI轻量模型', 128000, FALSE, 0.0010, 0.0010, TRUE, FALSE, 8000, TRUE, 3),

-- 通义千问
('4', 'qwen', 'qwen-turbo', 'Qwen Turbo', '通义千问超高速模型', 8000, TRUE, 0.0000, 0.0000, TRUE, FALSE, 2000, TRUE, 4),
('5', 'qwen', 'qwen-plus', 'Qwen Plus', '通义千问增强版', 32000, FALSE, 0.0080, 0.0080, TRUE, FALSE, 6000, TRUE, 5),
('6', 'qwen', 'qwen-max', 'Qwen Max', '通义千问最强模型', 30000, FALSE, 0.0200, 0.0200, TRUE, TRUE, 8000, TRUE, 6),

-- DeepSeek
('7', 'deepseek', 'deepseek-chat', 'DeepSeek Chat', 'DeepSeek对话模型', 16000, TRUE, 0.0001, 0.0002, TRUE, FALSE, 4000, TRUE, 7),
('8', 'deepseek', 'deepseek-coder', 'DeepSeek Coder', 'DeepSeek代码模型', 16000, FALSE, 0.0001, 0.0002, TRUE, FALSE, 4000, TRUE, 8),

-- 文心一言
('9', 'wenxin', 'ernie-speed', 'ERNIE Speed', '文心一言极速版', 8000, TRUE, 0.0000, 0.0000, TRUE, FALSE, 2000, TRUE, 9),
('10', 'wenxin', 'ernie-4.0', 'ERNIE 4.0', '文心大模型4.0', 8000, FALSE, 0.0120, 0.0120, TRUE, FALSE, 2000, TRUE, 10),

-- 腾讯混元
('11', 'hunyuan', 'hunyuan-lite', '混元Lite', '腾讯混元轻量版', 256000, TRUE, 0.0000, 0.0000, TRUE, FALSE, 6000, TRUE, 11),
('12', 'hunyuan', 'hunyuan-pro', '混元Pro', '腾讯混元专业版', 256000, FALSE, 0.0150, 0.0150, TRUE, TRUE, 6000, TRUE, 12),

-- OpenAI
('13', 'openai', 'gpt-4o-mini', 'GPT-4o Mini', 'OpenAI轻量模型', 128000, FALSE, 0.00015, 0.0006, TRUE, TRUE, 16000, TRUE, 13),
('14', 'openai', 'gpt-4o', 'GPT-4o', 'OpenAI最强模型', 128000, FALSE, 0.0025, 0.01, TRUE, TRUE, 4000, TRUE, 14);
```

---

## 7. AI集成方案

### 6.1 智谱AI集成

#### 6.1.1 免费方案选择

**GLM-4-Flash** (完全免费)

- 上下文长度: 128K
- 适用场景: 日常对话、指令解析
- 无需付费，永久免费

**新用户福利**

- 注册即送 **2000万 tokens**
- 足够支撑开发测试和初期运营

#### 6.1.2 Function Calling设计

```python
# AI可调用的函数定义
TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "fly_to",
            "description": "控制3D相机飞行到指定位置",
            "parameters": {
                "type": "object",
                "properties": {
                    "longitude": {
                        "type": "number",
                        "description": "目标经度"
                    },
                    "latitude": {
                        "type": "number",
                        "description": "目标纬度"
                    },
                    "height": {
                        "type": "number",
                        "description": "飞行高度(米)"
                    },
                    "duration": {
                        "type": "number",
                        "description": "飞行时长(秒)"
                    }
                },
                "required": ["longitude", "latitude"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "highlight_buildings",
            "description": "高亮显示指定的建筑物",
            "parameters": {
                "type": "object",
                "properties": {
                    "building_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "建筑ID列表"
                    },
                    "color": {
                        "type": "string",
                        "description": "高亮颜色(HEX)"
                    },
                    "effect": {
                        "type": "string",
                        "enum": ["solid", "blink", "pulse"],
                        "description": "高亮效果"
                    }
                },
                "required": ["building_ids", "color"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "query_buildings",
            "description": "查询符合条件的建筑物列表",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "城市名称"
                    },
                    "district": {
                        "type": "string",
                        "description": "区县名称"
                    },
                    "min_height": {
                        "type": "number",
                        "description": "最小高度(米)"
                    },
                    "max_height": {
                        "type": "number",
                        "description": "最大高度(米)"
                    },
                    "category": {
                        "type": "string",
                        "enum": ["office", "landmark", "residential", "commercial"],
                        "description": "建筑类型"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["normal", "abnormal", "high_risk"],
                        "description": "状态"
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "spatial_query_circle",
            "description": "圆形空间查询，获取指定半径范围内的建筑",
            "parameters": {
                "type": "object",
                "properties": {
                    "center": {
                        "type": "object",
                        "properties": {
                            "longitude": {"type": "number"},
                            "latitude": {"type": "number"}
                        },
                        "required": ["longitude", "latitude"]
                    },
                    "radius": {
                        "type": "number",
                        "description": "半径(米)"
                    },
                    "min_height": {
                        "type": "number",
                        "description": "最小高度(米)"
                    }
                },
                "required": ["center", "radius"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "sync_weather",
            "description": "同步指定城市的天气数据，并更新3D场景效果",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {
                        "type": "string",
                        "description": "城市名称"
                    }
                },
                "required": ["city"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "update_building_status",
            "description": "更新建筑的状态和风险等级",
            "parameters": {
                "type": "object",
                "properties": {
                    "building_id": {
                        "type": "string",
                        "description": "建筑ID"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["normal", "abnormal", "high_risk"],
                        "description": "状态"
                    },
                    "risk_level": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 3,
                        "description": "风险等级: 0-无, 1-低, 2-中, 3-高"
                    }
                },
                "required": ["building_id"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "set_scene_weather",
            "description": "设置3D场景的天气效果",
            "parameters": {
                "type": "object",
                "properties": {
                    "weather": {
                        "type": "string",
                        "enum": ["sunny", "rainy", "snowy", "foggy", "cloudy"],
                        "description": "天气类型"
                    },
                    "time_of_day": {
                        "type": "string",
                        "enum": ["day", "night", "dawn", "dusk"],
                        "description": "时段"
                    }
                }
            }
        }
    }
]
```

#### 6.1.3 角色预设Prompt

````python
PERSONA_PROMPTS = {
    "admin": """你是一个高效果断的城市管理系统助手。

风格特点：
- 回复简洁，直接执行指令
- 优先执行操作，减少解释
- 适合日常巡检、应急响应场景

示例行为：
用户："飞到中国尊"
你：直接调用 fly_to 函数，不进行额外说明
""",

    "planner": """你是一个专业的城市规划分析助手。

风格特点：
- 注重数据分析，提供详细报告
- 执行操作前会先查询相关数据
- 提供空间分析和建议

示例行为：
用户："分析朝阳区高楼分布"
你：
1. 先调用 query_buildings 查询朝阳区建筑
2. 生成分析报告（数量、高度分布、类型占比）
3. 调用 fly_to 和 highlight_buildings 进行可视化
""",

    "geek": """你是一个技术专家模式的助手。

风格特点：
- 展示完整的思考过程和技术细节
- 输出解析出的JSON指令
- 适合调试和开发场景

示例行为：
用户："飞到中国尊"
你：
"已解析您的指令：
```json
{
  "function": "fly_to",
  "parameters": {
    "longitude": 116.4347,
    "latitude": 39.9087,
    "height": 1000
  }
}
````

正在执行飞行操作..."
"""
}

BASE_SYSTEM_PROMPT = """你是语控未来城系统的AI控制大脑，负责理解用户自然语言指令并控制系统动作。

核心能力：

1. 理解用户的城市查询和控制指令
2. 调用相应的函数接口执行操作
3. 结合城市数据提供分析建议

重要规则：

- 必须使用Function Calling方式执行操作
- 地理坐标使用WGS-84坐标系
- 建筑高度单位为米
- 保持友好专业的语气
- 不确定的信息要明确告知用户

可用的操作工具见functions定义。
"""

````

### 6.2 API调用示例

```python
from zhipuai import ZhipuAI

client = ZhipuAI(api_key=user_api_key)  # 使用用户自定义Key

response = client.chat.completions.create(
    model=user_config.model_name,  # 如 "glm-4-flash"
    messages=[
        {
            "role": "system",
            "content": BASE_SYSTEM_PROMPT + PERSONA_PROMPTS[user_config.persona]
        },
        {
            "role": "user",
            "content": "分析一下朝阳区高度超过200米的建筑"
        }
    ],
    tools=TOOLS,
    temperature=user_config.temperature,
    top_p=user_config.top_p
)
````

---

## 7. 3D地图数据方案

### 7.1 免费数据源选择

#### 7.1.1 OSM Buildings (推荐)

**优势**:

- 完全免费，开源数据
- 全球覆盖，包括中国主要城市
- 支持Cesium直接加载
- 持续更新

**加载方式**:

```javascript
const viewer = new Cesium.Viewer("cesiumContainer", {
  terrainProvider: Cesium.createWorldTerrain(),
});

// 加载OSM 3D建筑物
const osmBuildings = await Cesium.createOsmBuildingsAsync();
viewer.scene.primitives.add(osmBuildings);
```

**覆盖城市**:

- 北京、上海、广州、深圳等一线城市
- 大部分省会城市
- 持续扩展中

#### 7.1.2 高德地图底图

**免费额度**:

- 个人开发者: 30万次/日
- 适合中小型应用

**加载方式**:

```javascript
// 高德卫星影像
viewer.imageryLayers.addImageryProvider(
  new Cesium.UrlTemplateImageryProvider({
    url: "https://webst02.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}",
    maximumLevel: 18,
  }),
);

// 高德路网注记
viewer.imageryLayers.addImageryProvider(
  new Cesium.UrlTemplateImageryProvider({
    url: "https://webst02.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}",
    maximumLevel: 18,
  }),
);
```

#### 7.1.3 备选方案: Mapbox

**免费额度**:

- 50,000次/月

**优势**:

- 提供3D建筑物
- 数据质量高

### 7.2 坐标系转换

**重要**: 高德地图使用GCJ-02坐标系，Cesium使用WGS-84，必须进行转换。

```javascript
// GCJ-02 转 WGS-84
function gcj02ToWgs84(lng, lat) {
  const a = 6378245.0;
  const ee = 0.00669342162296594323;

  if (outOfChina(lng, lat)) {
    return [lng, lat];
  }

  let dLat = transformLat(lng - 105.0, lat - 35.0);
  let dLng = transformLng(lng - 105.0, lat - 35.0);
  const radLat = (lat / 180.0) * Math.PI;
  let magic = Math.sin(radLat);
  magic = 1 - ee * magic * magic;
  const sqrtMagic = Math.sqrt(magic);
  dLat = (dLat * 180.0) / (((a * (1 - ee)) / (magic * sqrtMagic)) * Math.PI);
  dLng = (dLng * 180.0) / ((a / sqrtMagic) * Math.cos(radLat) * Math.PI);
  const mgLat = lat + dLat;
  const mgLng = lng + dLng;

  return [lng * 2 - mgLng, lat * 2 - mgLat];
}
```

### 7.3 自定义建筑加载

对于MySQL中的自定义建筑数据:

```javascript
// 从API获取建筑列表
const buildings = await api.getBuildings();

// 为每个建筑创建3D实体
buildings.forEach((building) => {
  viewer.entities.add({
    id: building.id,
    name: building.name,
    position: Cesium.Cartesian3.fromDegrees(
      building.longitude,
      building.latitude,
      building.height / 2,
    ),
    box: {
      dimensions: new Cesium.Cartesian3(
        50, // 默认宽度
        50, // 默认深度
        building.height,
      ),
      material:
        building.status === "high_risk"
          ? Cesium.Color.RED.withAlpha(0.8)
          : Cesium.Color.BLUE.withAlpha(0.5),
    },
    properties: {
      ...building,
    },
  });
});
```

---

## 8. 外部API集成

### 8.1 和风天气API

**免费额度**: 50,000次/月

**集成方案**:

```python
import httpx

async def get_weather(city: str) -> dict:
    """获取城市天气信息"""
    params = {
        "location": city,  # 城市名称
        "key": QWEATHER_API_KEY
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(
            "https://devapi.qweather.com/v7/weather/now",
            params=params
        )
        return response.json()
```

### 8.2 高德地图API

**免费额度**: 30万次/日 (个人开发者)

**POI搜索**:

```python
async def search_poi(keyword: str, city: str) -> dict:
    """POI搜索"""
    params = {
        "key": AMAP_API_KEY,
        "keywords": keyword,
        "city": city,
        "output": "json"
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(
            "https://restapi.amap.com/v5/place/text",
            params=params
        )
        return response.json()
```

### 8.3 智谱AI API

**免费额度**:

- GLM-4-Flash: 完全免费
- 新用户: 2000万tokens

```python
from zhipuai import ZhipuAI

async def chat_with_ai(messages: list, config: dict):
    """AI对话"""
    client = ZhipuAI(api_key=config["api_key"])

    response = client.chat.completions.create(
        model=config["model_name"],
        messages=messages,
        tools=TOOLS,
        temperature=config["temperature"]
    )

    return response
```

---

## 9. 安全设计

### 9.1 认证安全

#### 9.1.1 JWT Token设计

```python
from datetime import datetime, timedelta
import jwt

SECRET_KEY = "your-secret-key"  # 生产环境使用环境变量
ALGORITHM = "HS256"

def create_access_token(user_id: str) -> str:
    """创建访问Token"""
    expire = datetime.utcnow() + timedelta(hours=24)
    payload = {
        "user_id": user_id,
        "exp": expire,
        "type": "access"
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user_id: str) -> str:
    """创建刷新Token"""
    expire = datetime.utcnow() + timedelta(days=7)
    payload = {
        "user_id": user_id,
        "exp": expire,
        "type": "refresh"
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
```

#### 9.1.2 密码加密

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """加密密码"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    return pwd_context.verify(plain_password, hashed_password)
```

### 9.2 API Key加密存储

```python
from cryptography.fernet import Fernet

KEY = Fernet.generate_key()  # 生产环境使用固定密钥
cipher_suite = Fernet(KEY)

def encrypt_api_key(api_key: str) -> str:
    """加密API Key"""
    return cipher_suite.encrypt(api_key.encode()).decode()

def decrypt_api_key(encrypted_key: str) -> str:
    """解密API Key"""
    return cipher_suite.decrypt(encrypted_key.encode()).decode()
```

### 9.3 API限流

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.post("/api/v1/chat/completions")
@limiter.limit("10/minute")  # 每分钟最多10次
async def chat_completion(request: Request, ...):
    ...
```

### 9.4 CORS配置

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],  # 开发环境
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

## 10. 部署方案

### 10.1 开发环境

**前端**:

```bash
cd frontend
npm install
npm run dev
# 访问 http://localhost:5173
```

**后端**:

```bash
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn main:app --reload --port 8000
# 访问 http://localhost:8000
```

### 10.2 生产环境推荐方案

#### 10.2.1 前端部署

**方案1: Vercel/Netlify (推荐)**

- 完全免费
- 自动HTTPS
- 全球CDN

```bash
npm run build
# 将 dist 目录部署到 Vercel
```

**方案2: Nginx**

```nginx
server {
    listen 80;
    server_name yourdomain.com;

    root /var/www/smart-city/dist;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location /api {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

#### 10.2.2 后端部署

**方案1: Railway/Render (推荐)**

- 免费额度充足
- 支持Python
- 自动部署

**方案2: 腾讯云/阿里云轻量服务器**

- 价格便宜 (~50元/月)
- 配置灵活

```bash
# 使用 systemd 管理
# /etc/systemd/system/smart-city.service
[Unit]
Description=Smart City Backend
After=network.target

[Service]
User=www-data
WorkingDirectory=/var/www/smart-city/backend
Environment="PATH=/var/www/smart-city/backend/venv/bin"
ExecStart=/var/www/smart-city/backend/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8000

[Install]
WantedBy=multi-user.target
```

#### 10.2.3 MySQL部署

**方案1: 免费云数据库**

- Railway MySQL: 免费额度
- PlanetScale: 永久免费版
- Supabase: 免费版500MB

**方案2: 自建MySQL**

```bash
# Docker部署
docker run -d \
  --name smart-city-mysql \
  -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=yourpassword \
  -e MYSQL_DATABASE=smart_city \
  -v mysql-data:/var/lib/mysql \
  mysql:8.0
```

---

## 11. 性能优化

### 11.1 前端优化

1. **代码分割**: React.lazy + Suspense
2. **图片优化**: WebP格式 + 懒加载
3. **Cesium优化**:
   - 按需加载3D Tiles
   - 视锥体剔除
   - LOD控制

### 11.2 后端优化

1. **数据库索引**: 为常用查询字段添加索引
2. **Redis缓存**: 缓存热点数据
3. **异步处理**: 使用async/await
4. **连接池**: SQLAlchemy连接池配置

```python
# 数据库连接池配置
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=0,
    pool_pre_ping=True
)
```

---

## 12. 成本估算

### 12.1 开发成本

| 项目    | 成本       | 说明                 |
| ------- | ---------- | -------------------- |
| 域名    | ¥50-100/年 | 可选                 |
| 服务器  | ¥0-50/月   | 免费方案或轻量服务器 |
| 数据库  | ¥0         | 免费云数据库         |
| API调用 | ¥0         | 使用免费额度         |

### 12.2 API免费额度汇总

| 服务            | 免费额度     | 说明         |
| --------------- | ------------ | ------------ |
| 智谱GLM-4-Flash | 无限         | 完全免费     |
| 智谱新用户      | 2000万tokens | 一次性赠送   |
| 和风天气        | 5万次/月     | 足够个人使用 |
| 高德地图        | 30万次/日    | 个人开发者   |
| OSM Buildings   | 无限         | 开源免费     |

**结论**: 整个项目可完全基于免费方案运行！

---

## 13. 实施计划

### Phase 1: 基础搭建 (Week 1-2)

- [x] 项目初始化 (前后端)
- [x] 数据库设计与创建
- [x] 用户认证系统 (JWT)
- [x] 基础API框架搭建

### Phase 2: 3D场景 (Week 3-4)

- [ ] Cesium集成与配置
- [ ] OSM Buildings加载
- [ ] 高德地图底图集成
- [ ] 坐标系转换实现
- [ ] 基础相机控制

### Phase 3: AI集成 (Week 5-6)

- [ ] 智谱AI集成
- [ ] Function Calling实现
- [ ] 角色预设设计
- [ ] 对话管理界面

### Phase 4: 业务功能 (Week 7-8)

- [ ] 建筑数据管理
- [ ] 空间查询功能
- [ ] 天气集成
- [ ] AI指令执行

### Phase 5: 优化上线 (Week 9-10)

- [ ] 性能优化
- [ ] 安全加固
- [ ] 部署上线
- [ ] 文档完善

---

## 14. 参考资源

### 14.1 技术文档

- [Cesium.js 官方文档](https://cesium.com/learn/)
- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [智谱AI 开放平台](https://open.bigmodel.cn/)
- [Ant Design React](https://ant.design/)

### 14.2 免费数据源

- [OpenStreetMap](https://www.openstreetmap.org/)
- [OSM Buildings](https://osmbuildings.org/)
- [和风天气](https://dev.qweather.com/)
- [高德开放平台](https://lbs.amap.com/)

### 14.3 开源项目参考

- [Cesium for Unreal](https://github.com/CesiumGS/cesium-unreal)
- [Cesium React Examples](https://github.com/AnalyticalGraphicsInc/cesium-react)

---

## 附录

### A. 坐标系转换算法

```python
import math

def gcj02_to_wgs84(lng: float, lat: float) -> tuple:
    """GCJ-02 转 WGS-84"""
    a = 6378245.0
    ee = 0.00669342162296594323

    if _out_of_china(lng, lat):
        return lng, lat

    d_lat = _transform_lat(lng - 105.0, lat - 35.0)
    d_lng = _transform_lng(lng - 105.0, lat - 35.0)

    rad_lat = lat / 180.0 * math.pi
    magic = math.sin(rad_lat)
    magic = 1 - ee * magic * magic
    sqrt_magic = math.sqrt(magic)

    d_lat = (d_lat * 180.0) / ((a * (1 - ee)) / (magic * sqrt_magic) * math.pi)
    d_lng = (d_lng * 180.0) / (a / sqrt_magic * math.cos(rad_lat) * math.pi)

    mg_lat = lat + d_lat
    mg_lng = lng + d_lng

    return lng * 2 - mg_lng, lat * 2 - mg_lat

def _transform_lat(lng: float, lat: float) -> float:
    ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \
          0.1 * lng * lat + 0.2 * math.sqrt(abs(lng))
    ret += (20.0 * math.sin(6.0 * lng * math.pi) + 20.0 *
            math.sin(2.0 * lng * math.pi)) * 2.0 / 3.0
    ret += (20.0 * math.sin(lat * math.pi) + 40.0 *
            math.sin(lat / 3.0 * math.pi)) * 2.0 / 3.0
    ret += (160.0 * math.sin(lat / 12.0 * math.pi) + 320 *
            math.sin(lat * math.pi / 30.0)) * 2.0 / 3.0
    return ret

def _transform_lng(lng: float, lat: float) -> float:
    ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \
          0.1 * lng * lat + 0.1 * math.sqrt(abs(lng))
    ret += (20.0 * math.sin(6.0 * lng * math.pi) + 20.0 *
            math.sin(2.0 * lng * math.pi)) * 2.0 / 3.0
    ret += (20.0 * math.sin(lng * math.pi) + 40.0 *
            math.sin(lng / 3.0 * math.pi)) * 2.0 / 3.0
    ret += (150.0 * math.sin(lng / 12.0 * math.pi) + 300.0 *
            math.sin(lng / 30.0 * math.pi)) * 2.0 / 3.0
    return ret

def _out_of_china(lng: float, lat: float) -> bool:
    return not (73.66 < lng < 135.05 and 3.86 < lat < 53.55)
```

### B. 项目目录结构

```
smart-city/
├── frontend/                 # 前端项目
│   ├── public/
│   ├── src/
│   ├── package.json
│   └── vite.config.ts
├── backend/                  # 后端项目
│   ├── app/
│   │   ├── api/
│   │   ├── core/
│   │   ├── models/
│   │   ├── schemas/
│   │   └── services/
│   ├── main.py
│   └── requirements.txt
├── docs/                     # 文档
│   ├── 需求.md
│   └── 系统设计文档.md
├── database/                 # 数据库脚本
│   ├── init.sql
│   └── seed.sql
└── README.md
```

---

## 15. 数据库迁移方案 (Alembic)

### 15.1 为什么需要数据库迁移

基于SQLAlchemy最佳实践，使用Alembic进行数据库版本控制和迁移：
- 数据库schema版本管理
- 安全的增量式迁移
- 支持升级和回滚
- 团队协作的数据库同步

### 15.2 Alembic配置

**安装依赖**:
```bash
pip install alembic
alembic init alembic
```

**alembic.ini配置**:
```ini
[alembic]
# 数据库连接URL（从环境变量读取）
sqlalchemy.url = mysql+pymysql://user:pass@localhost/smart_city

# 迁移脚本目录
script_location = alembic

# 迁移文件命名格式
file_template = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d_%%(rev)s_%%(slug)s

# 时区设置
timezone = Asia/Shanghai
```

**env.py配置**:
```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context

# 导入Base以获取所有模型
from app.models import Base
from app.core.config import settings

# Alembic Config对象
config = context.config

# 从settings设置数据库URL
config.set_main_option('sqlalchemy.url', settings.DATABASE_URL)

# 解释日志配置
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# 设置target_metadata
target_metadata = Base.metadata

# 其他配置...
```

### 15.3 迁移脚本示例

**创建迁移**:
```bash
# 生成迁移脚本
alembic revision --autogenerate -m "add user avatar field"

# 手动创建迁移
alembic revision -m "create buildings table"
```

**迁移脚本示例**:
```python
"""add user avatar url

Revision ID: 20260130_001
Revises: 20260130_000
Create Date: 2026-01-30 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '20260130_001'
down_revision = '20260130_000'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """添加avatar_url字段"""
    op.add_column(
        'tb_users',
        sa.Column('avatar_url', sa.String(500), nullable=True)
    )

    # 添加索引
    op.create_index(
        'idx_users_avatar',
        'tb_users',
        ['avatar_url']
    )


def downgrade() -> None:
    """删除avatar_url字段"""
    op.drop_index('idx_users_avatar', table_name='tb_users')
    op.drop_column('tb_users', 'avatar_url')
```

### 15.4 执行迁移

```bash
# 升级到最新版本
alembic upgrade head

# 升级到指定版本
alembic upgrade 20260130_001

# 回滚一个版本
alembic downgrade -1

# 回滚到初始状态
alembic downgrade base

# 查看当前版本
alembic current

# 查看迁移历史
alembic history
```

### 15.5 生产环境迁移最佳实践

1. **备份先行**：迁移前先备份数据库
2. **测试验证**：在staging环境先测试迁移
3. **分批执行**：大数据量迁移分批次执行
4. **监控日志**：实时监控迁移过程
5. **回滚准备**：确保downgrade脚本可用

---

## 16. 测试策略

### 16.1 测试金字塔

```
           /\
          /  \
         / E2E\        10% - 端到端测试
        /------\
       /        \
      /集成测试  \     30% - API集成测试
     /----------\
    /            \
   /  单元测试    \   60% - 单元测试
  /----------------\
```

### 16.2 后端测试 (Pytest)

**安装依赖**:
```bash
pip install pytest pytest-asyncio pytest-cov httpx
```

**测试配置**:
```python
# conftest.py
import pytest
from httpx import AsyncClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.database import get_db
from app.models import Base

# 测试数据库
SQLALCHEMY_DATABASE_URL = "mysql+pymysql://test:test@localhost/smart_city_test"

engine = create_engine(SQLALCHEMY_DATABASE_URL)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="function")
def db():
    """创建测试数据库会话"""
    Base.metadata.create_all(bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
async def client(db):
    """创建测试客户端"""
    def override_get_db():
        try:
            yield db
        finally:
            pass

    app.dependency_overrides[get_db] = override_get_db
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
    app.dependency_overrides.clear()
```

**单元测试示例**:
```python
# tests/test_auth.py
import pytest
from httpx import AsyncClient

class TestAuth:
    """认证模块测试"""

    @pytest.mark.asyncio
    async def test_register_user(self, client: AsyncClient):
        """测试用户注册"""
        response = await client.post(
            "/api/v1/auth/register",
            json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "password123",
                "full_name": "测试用户"
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 200
        assert "user_id" in data["data"]

    @pytest.mark.asyncio
    async def test_register_duplicate_username(self, client: AsyncClient):
        """测试重复用户名注册"""
        # 第一次注册
        await client.post(
            "/api/v1/auth/register",
            json={
                "username": "testuser",
                "email": "test1@example.com",
                "password": "password123"
            }
        )

        # 第二次注册相同用户名
        response = await client.post(
            "/api/v1/auth/register",
            json={
                "username": "testuser",
                "email": "test2@example.com",
                "password": "password123"
            }
        )
        assert response.status_code == 400

    @pytest.mark.asyncio
    async def test_login_success(self, client: AsyncClient):
        """测试登录成功"""
        # 先注册
        await client.post(
            "/api/v1/auth/register",
            json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "password123"
            }
        )

        # 登录
        response = await client.post(
            "/api/v1/auth/login",
            json={
                "username": "testuser",
                "password": "password123"
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data["data"]
        assert data["data"]["token_type"] == "bearer"
```

**API集成测试**:
```python
# tests/test_api.py
import pytest
from httpx import AsyncClient

class TestBuildingAPI:
    """建筑API测试"""

    @pytest.mark.asyncio
    async def test_get_buildings(self, client: AsyncClient, auth_token: str):
        """测试获取建筑列表"""
        response = await client.get(
            "/api/v1/buildings",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        assert response.status_code == 200
        data = response.json()
        assert "items" in data["data"]

    @pytest.mark.asyncio
    async def test_spatial_query(self, client: AsyncClient, auth_token: str):
        """测试空间查询"""
        response = await client.post(
            "/api/v1/buildings/spatial/circle",
            headers={"Authorization": f"Bearer {auth_token}"},
            json={
                "center": {
                    "longitude": 116.4347,
                    "latitude": 39.9087
                },
                "radius": 1000
            }
        )
        assert response.status_code == 200
```

**运行测试**:
```bash
# 运行所有测试
pytest

# 运行指定测试文件
pytest tests/test_auth.py

# 生成覆盖率报告
pytest --cov=app --cov-report=html

# 运行并显示详细输出
pytest -v -s
```

### 16.3 前端测试 (Vitest + React Testing Library)

**安装依赖**:
```bash
npm install -D vitest @testing-library/react @testing-library/jest-dom
```

**vitest.config.ts**:
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
});
```

**组件测试示例**:
```typescript
// src/components/__tests__/AIChatPanel.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { AIChatPanel } from '../AIChatPanel';

describe('AIChatPanel', () => {
  it('renders chat interface', () => {
    render(<AIChatPanel />);
    expect(screen.getByPlaceholderText('输入消息...')).toBeInTheDocument();
  });

  it('sends message on button click', () => {
    const mockSendMessage = vi.fn();
    render(<AIChatPanel onSendMessage={mockSendMessage} />);

    const input = screen.getByPlaceholderText('输入消息...');
    const button = screen.getByRole('button', { name: '发送' });

    fireEvent.change(input, { target: { value: '测试消息' } });
    fireEvent.click(button);

    expect(mockSendMessage).toHaveBeenCalledWith('测试消息');
  });

  it('displays AI response', () => {
    const { getByText } = render(
      <AIChatPanel messages={[
        { role: 'assistant', content: 'AI回复' }
      ]} />
    );

    expect(getByText('AI回复')).toBeInTheDocument();
  });
});
```

### 16.4 E2E测试 (Playwright)

```bash
npm install -D @playwright/test
```

```typescript
// e2e/chat.spec.ts
import { test, expect } from '@playwright/test';

test.describe('AI Chat Flow', () => {
  test('user can chat with AI', async ({ page }) => {
    // 访问首页
    await page.goto('/');

    // 登录
    await page.click('text=登录');
    await page.fill('[name="username"]', 'testuser');
    await page.fill('[name="password"]', 'password123');
    await page.click('button:has-text("登录")');

    // 等待跳转到主页
    await expect(page).toHaveURL('/');

    // 发送消息
    await page.fill('[data-testid="chat-input"]', '飞到中国尊');
    await page.click('button:has-text("发送")');

    // 等待AI回复
    await expect(page.locator('[data-testid="ai-message"]')).toBeVisible();
  });
});
```

---

## 17. 错误处理与日志

### 17.1 统一异常处理

**自定义异常类**:
```python
# app/core/exceptions.py
class AppException(Exception):
    """应用基础异常"""
    def __init__(self, message: str, code: int = 400):
        self.message = message
        self.code = code
        super().__init__(self.message)

class NotFoundException(AppException):
    """资源未找到"""
    def __init__(self, message: str = "资源未找到"):
        super().__init__(message, 404)

class UnauthorizedException(AppException):
    """未授权"""
    def __init__(self, message: str = "未授权访问"):
        super().__init__(message, 401)

class BusinessException(AppException):
    """业务逻辑异常"""
    def __init__(self, message: str, code: int = 400):
        super().__init__(message, code)

class ExternalAPIException(AppException):
    """外部API异常"""
    def __init__(self, message: str = "外部服务调用失败"):
        super().__init__(message, 502)
```

**全局异常处理器**:
```python
# app/core/error_handlers.py
from fastapi import Request
from fastapi.responses import JSONResponse
from app.core.exceptions import AppException
import logging

logger = logging.getLogger(__name__)

async def app_exception_handler(request: Request, exc: AppException):
    """处理应用自定义异常"""
    logger.error(f"AppException: {exc.message}", exc_info=True)

    return JSONResponse(
        status_code=exc.code,
        content={
            "code": exc.code,
            "message": exc.message,
            "data": None,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

async def general_exception_handler(request: Request, exc: Exception):
    """处理所有未捕获的异常"""
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)

    return JSONResponse(
        status_code=500,
        content={
            "code": 500,
            "message": "服务器内部错误",
            "data": None,
            "timestamp": datetime.utcnow().isoformat()
        }
    )
```

**注册异常处理器**:
```python
# app/main.py
from fastapi import FastAPI
from app.core.exceptions import AppException
from app.core.error_handlers import app_exception_handler, general_exception_handler

app = FastAPI()

app.add_exception_handler(AppException, app_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)
```

### 17.2 日志配置

**日志配置**:
```python
# app/core/logging.py
import logging
import sys
from pathlib import Path

def setup_logging():
    """配置应用日志"""

    # 创建logs目录
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)

    # 配置日志格式
    log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"

    # 配置root logger
    logging.basicConfig(
        level=logging.INFO,
        format=log_format,
        datefmt=date_format,
        handlers=[
            # 控制台输出
            logging.StreamHandler(sys.stdout),

            # 文件输出 - 所有日志
            logging.FileHandler(
                log_dir / "app.log",
                encoding="utf-8"
            ),

            # 文件输出 - 错误日志
            logging.FileHandler(
                log_dir / "error.log",
                encoding="utf-8",
                level=logging.ERROR
            )
        ]
    )

    # 第三方库日志级别
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("sqlalchemy").setLevel(logging.WARNING)

    return logging.getLogger(__name__)
```

**结构化日志**:
```python
# app/utils/logger.py
import logging
import json
from datetime import datetime

class StructuredLogger:
    """结构化日志记录器"""

    def __init__(self, name: str):
        self.logger = logging.getLogger(name)

    def log_api_request(
        self,
        method: str,
        path: str,
        user_id: str = None,
        status_code: int = None,
        duration_ms: float = None
    ):
        """记录API请求"""
        log_data = {
            "event": "api_request",
            "timestamp": datetime.utcnow().isoformat(),
            "method": method,
            "path": path,
            "user_id": user_id,
            "status_code": status_code,
            "duration_ms": duration_ms
        }
        self.logger.info(json.dumps(log_data, ensure_ascii=False))

    def log_ai_call(
        self,
        model: str,
        tokens_used: int,
        user_id: str = None,
        error: str = None
    ):
        """记录AI调用"""
        log_data = {
            "event": "ai_call",
            "timestamp": datetime.utcnow().isoformat(),
            "model": model,
            "tokens_used": tokens_used,
            "user_id": user_id,
            "error": error
        }
        if error:
            self.logger.error(json.dumps(log_data, ensure_ascii=False))
        else:
            self.logger.info(json.dumps(log_data, ensure_ascii=False))

# 使用示例
logger = StructuredLogger(__name__)
logger.log_api_request("GET", "/api/v1/buildings", user_id="xxx", status_code=200, duration_ms=123.45)
```

### 17.3 请求日志中间件

```python
# app/middleware/logging.py
import time
import uuid
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response

class LoggingMiddleware(BaseHTTPMiddleware):
    """请求日志中间件"""

    async def dispatch(self, request: Request, call_next):
        # 生成请求ID
        request_id = str(uuid.uuid4())
        request.state.request_id = request_id

        # 记录开始时间
        start_time = time.time()

        # 记录请求
        logger.info(f"Request started: {request.method} {request.url.path} [{request_id}]")

        # 处理请求
        try:
            response = await call_next(request)

            # 计算处理时长
            duration = time.time() - start_time

            # 记录响应
            logger.info(
                f"Request completed: {request.method} {request.url.path} "
                f"[{request_id}] - Status: {response.status_code} - "
                f"Duration: {duration:.3f}s"
            )

            # 添加请求ID到响应头
            response.headers["X-Request-ID"] = request_id

            return response

        except Exception as e:
            # 记录错误
            duration = time.time() - start_time
            logger.error(
                f"Request failed: {request.method} {request.url.path} "
                f"[{request_id}] - Error: {str(e)} - Duration: {duration:.3f}s",
                exc_info=True
            )
            raise
```

**注册中间件**:
```python
# app/main.py
from app.middleware.logging import LoggingMiddleware

app.add_middleware(LoggingMiddleware)
```

---

## 18. 性能优化策略

### 18.1 前端性能优化

#### 18.1.1 代码分割与懒加载

```typescript
// 路由懒加载
import { lazy } from 'react';

const HomePage = lazy(() => import('./pages/HomePage'));
const LoginPage = lazy(() => import('./pages/LoginPage'));

// 组件懒加载
const CesiumViewer = lazy(() => import('./components/CesiumViewer'));
```

#### 18.1.2 Cesium性能优化

```javascript
// 启用请求渲染模式
const viewer = new Cesium.Viewer('cesiumContainer', {
  requestRenderMode: true,  // 仅在需要时渲染
  maximumRenderTimeChange: Infinity  // 禁止自动渲染
});

// 控制LOD（细节层次）
viewer.scene.globe.maximumScreenSpaceError = 2;  // 默认值

// 限制视锥体内的裁剪
viewer.scene.fog.enabled = true;
viewer.scene.fog.density = 0.0002;

// 异步加载3D Tiles
const tileset = await Cesium.Cesium3DTileset.fromUrl(url, {
  maximumScreenSpaceError: 2,
  maximumMemoryUsage: 512  // 限制内存使用
});
```

#### 18.1.3 React性能优化

```typescript
// 使用React.memo避免不必要的重渲染
export const BuildingCard = React.memo(({ building }: { building: Building }) => {
  // ...
});

// 使用useMemo缓存计算结果
const statistics = useMemo(() => {
  return calculateStatistics(buildings);
}, [buildings]);

// 使用useCallback缓存函数
const handleBuildingClick = useCallback((building: Building) => {
  setSelectedBuilding(building);
}, []);
```

#### 18.1.4 资源优化

```javascript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'cesium': ['cesium'],
          'react-vendor': ['react', 'react-dom'],
          'ui-vendor': ['antd', '@ant-design/icons']
        }
      }
    },
    chunkSizeWarningLimit: 1000
  }
});
```

### 18.2 后端性能优化

#### 18.2.1 数据库优化

**索引优化**:
```sql
-- 复合索引
CREATE INDEX idx_buildings_city_height ON tb_buildings(city, height DESC);

-- 覆盖索引
CREATE INDEX idx_buildings_list ON tb_buildings(city, status, category, name);

-- 空间索引（MySQL 8.0+）
CREATE SPATIAL INDEX idx_buildings_location ON tb_buildings(longitude, latitude);
```

**查询优化**:
```python
# 使用select_related减少查询次数
# 不推荐：N+1查询
buildings = session.query(Building).all()
for b in buildings:
    print(b.district.name)  # 每次都查询district

# 推荐：使用join
buildings = session.query(Building).options(
    selectinload(Building.district)
).all()

# 使用exists代替count
if session.query(Building.id).filter_by(name="中国尊").first():
    pass  # 存在

# 推荐
if session.query(
    session.query(Building).filter_by(name="中国尊").exists()
).scalar():
    pass
```

#### 18.2.2 缓存策略

**Redis缓存**:
```python
# app/core/cache.py
from redis import Redis
import json
from typing import Optional

class CacheService:
    def __init__(self, redis_url: str):
        self.redis = Redis.from_url(redis_url, decode_responses=True)

    def get(self, key: str) -> Optional[dict]:
        """获取缓存"""
        data = self.redis.get(key)
        return json.loads(data) if data else None

    def set(self, key: str, value: dict, ttl: int = 3600):
        """设置缓存"""
        self.redis.setex(key, ttl, json.dumps(value, ensure_ascii=False))

    def delete(self, key: str):
        """删除缓存"""
        self.redis.delete(key)

# 使用装饰器缓存
from functools import wraps

def cache_result(ttl: int = 3600, key_prefix: str = ""):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存key
            cache_key = f"{key_prefix}:{str(args)}:{str(kwargs)}"

            # 尝试从缓存获取
            cached = cache.get(cache_key)
            if cached:
                return cached

            # 执行函数
            result = await func(*args, **kwargs)

            # 存入缓存
            cache.set(cache_key, result, ttl)

            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(ttl=1800, key_prefix="building")
async def get_building(building_id: str):
    return await session.query(Building).filter_by(id=building_id).first()
```

#### 18.2.3 异步处理

```python
# app/services/background_tasks.py
from fastapi import BackgroundTasks
import asyncio

async def process_ai_request_async(session_id: str, message: str):
    """异步处理AI请求"""
    # 1. 保存消息到数据库
    await save_message(session_id, "user", message)

    # 2. 调用AI API
    response = await call_ai_api(message)

    # 3. 保存AI响应
    await save_message(session_id, "assistant", response["content"])

    # 4. 执行动作
    for action in response.get("actions", []):
        await execute_action(action)

    return response

# 在路由中使用
@router.post("/chat/completions")
async def chat_completion(
    request: ChatRequest,
    background_tasks: BackgroundTasks
):
    """提交聊天请求"""
    # 立即返回session_id
    session_id = str(uuid.uuid4())

    # 后台处理
    background_tasks.add_task(
        process_ai_request_async,
        session_id,
        request.message
    )

    return {
        "code": 200,
        "data": {
            "session_id": session_id,
            "message": "请求已提交，正在处理中..."
        }
    }
```

#### 18.2.4 数据库连接池优化

```python
# app/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    DATABASE_URL,
    echo=False,  # 生产环境关闭SQL日志
    pool_size=20,  # 连接池大小
    max_overflow=40,  # 最大溢出连接数
    pool_pre_ping=True,  # 连接前ping检测
    pool_recycle=3600,  # 连接回收时间（秒）
    pool_timeout=30,  # 获取连接超时时间
    connect_args={
        "charset": "utf8mb4",
        "connect_timeout": 10
    }
)

AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)
```

### 18.3 API性能优化

#### 18.3.1 响应压缩

```python
# app/main.py
from fastapi.middleware.gzip import GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=1000)
```

#### 18.3.2 分页优化

```python
# 使用游标分页代替偏移分页
class CursorPagination:
    """游标分页（更适合大数据量）"""

    def __init__(self, page_size: int = 20):
        self.page_size = page_size

    async def paginate(self, query: Query, cursor: str = None):
        if cursor:
            # 假设cursor是最后一条记录的ID
            query = query.filter(Building.id > cursor)

        items = await query.limit(self.page_size + 1).all()

        has_more = len(items) > self.page_size
        items = items[:self.page_size]

        next_cursor = items[-1].id if items and has_more else None

        return {
            "items": items,
            "next_cursor": next_cursor,
            "has_more": has_more
        }
```

---

## 19. 监控与运维

### 19.1 健康检查

```python
# app/api/health.py
from fastapi import APIRouter, Depends
from sqlalchemy import text
from app.database import get_db

router = APIRouter()

@router.get("/health")
async def health_check():
    """基础健康检查"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }

@router.get("/health/detailed")
async def detailed_health_check(db = Depends(get_db)):
    """详细健康检查"""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "checks": {}
    }

    # 检查数据库连接
    try:
        result = await db.execute(text("SELECT 1"))
        health_status["checks"]["database"] = {
            "status": "healthy",
            "latency_ms": 1.23
        }
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["checks"]["database"] = {
            "status": "unhealthy",
            "error": str(e)
        }

    # 检查Redis连接（如果使用）
    # ...

    # 检查外部API
    # ...

    return health_status
```

### 19.2 性能监控

**Prometheus指标**:
```python
# app/middleware/prometheus.py
from prometheus_client import Counter, Histogram, generate_latest
from fastapi import Request
import time

# 定义指标
http_requests_total = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

http_request_duration_seconds = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

ai_tokens_used = Counter(
    'ai_tokens_used',
    'Total AI tokens consumed',
    ['model']
)

async def prometheus_middleware(request: Request, call_next):
    """Prometheus监控中间件"""
    start_time = time.time()

    response = await call_next(request)

    # 记录请求指标
    duration = time.time() - start_time
    http_requests_total.labels(
        method=request.method,
        endpoint=request.url.path,
        status=response.status_code
    ).inc()

    http_request_duration_seconds.labels(
        method=request.method,
        endpoint=request.url.path
    ).observe(duration)

    return response

# Prometheus端点
@router.get("/metrics")
async def metrics():
    """Prometheus指标"""
    return Response(content=generate_latest(), media_type="text/plain")
```

### 19.3 告警配置

```yaml
# alerting_rules.yml
groups:
  - name: smart_city_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors/sec"

      - alert: SlowAPIResponse
        expr: histogram_quantile(0.95, http_request_duration_seconds) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "API response time is slow"
          description: "95th percentile latency is {{ $value }}s"

      - alert: DatabaseConnectionPoolExhausted
        expr: sqlalchemy_pool_size < 5
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Database connection pool nearly exhausted"
```

---

## 20. 安全加固

### 20.1 安全最佳实践清单

#### 20.1.1 认证与授权

- [x] 使用JWT进行无状态认证
- [x] Token有效期管理（Access Token: 24h, Refresh Token: 7d）
- [x] 密码强度要求（至少8位，包含字母数字）
- [x] 密码使用bcrypt加密（cost=12）
- [x] API Key使用AES加密存储
- [x] 实现登录失败次数限制

#### 20.1.2 数据传输安全

- [x] 生产环境强制HTTPS
- [x] CORS配置白名单
- [x] 敏感数据不记录日志
- [x] SQL注入防护（使用ORM参数化查询）
- [x] XSS防护（前端输入转义）

#### 20.1.3 API安全

- [x] 实施API限流（每用户每分钟限制）
- [x] 请求体大小限制
- [x] 请求超时配置
- [x] 输入验证（Pydantic schema）
- [x] 输出过滤（隐藏敏感字段）

### 20.2 安全中间件

```python
# app/middleware/security.py
from fastapi import Request, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import time

security = HTTPBearer()

class SecurityMiddleware:
    """安全中间件"""

    # 限流配置（内存存储，生产环境用Redis）
    rate_limits = {}

    async def check_rate_limit(self, user_id: str, limit: int = 60):
        """检查限流"""
        now = int(time.time())
        minute = now // 60

        key = f"{user_id}:{minute}"

        if key in self.rate_limits:
            if self.rate_limits[key] >= limit:
                raise HTTPException(
                    status_code=429,
                    detail="请求过于频繁，请稍后再试"
                )
            self.rate_limits[key] += 1
        else:
            self.rate_limits[key] = 1
            # 清理旧数据
            old_key = f"{user_id}:{minute - 1}"
            if old_key in self.rate_limits:
                del self.rate_limits[old_key]
```

### 20.3 敏感数据处理

```python
# app/core/security.py
from pydantic import BaseModel, Field

# 用户响应模型（排除敏感字段）
class UserResponse(BaseModel):
    id: str
    username: str
    email: str
    full_name: str | None = None
    created_at: datetime

    class Config:
        from_attributes = True

# 自动排除password_hash等字段
class User(BaseModel):
    id: str
    username: str
    email: str
    password_hash: str = Field(exclude=True)  # 自动排除
```

---

## 21. 开发工具配置

### 21.1 代码质量工具

**后端 (Python)**:
```bash
# 安装工具
pip install black isort flake8 mypy pytest

# black - 代码格式化
black app/ --line-length=100

# isort - 导入排序
isort app/

# flake8 - 代码检查
flake8 app/ --max-line-length=100

# mypy - 类型检查
mypy app/
```

**配置文件**:
```ini
# pyproject.toml
[tool.black]
line-length = 100
target-version = ['py39']

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
```

**前端 (TypeScript)**:
```bash
# 安装工具
npm install -D eslint prettier

# ESLint - 代码检查
npm run lint

# Prettier - 代码格式化
npm run format
```

**配置文件**:
```json
// .eslintrc.json
{
  "extends": [
    "react-app",
    "plugin:@typescript-eslint/recommended"
  ],
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  }
}

// .prettierrc
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

### 21.2 Git Hooks

**安装husky**:
```bash
npm install -D husky lint-staged
npx husky install
```

**配置Git Hooks**:
```json
// package.json
{
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{py}": [
      "black",
      "isort",
      "flake8"
    ]
  }
}
```

**Pre-commit Hook**:
```bash
# .husky/pre-commit
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged

# 后端检查
cd backend
black app/ --check
isort app/ --check-only
flake8 app/
```

---

## 22. 开源项目最佳实践总结

基于对Cesium、FastAPI、React、SQLAlchemy等开源项目的分析，总结以下关键最佳实践：

### 22.1 架构设计

1. **模块化设计**
   - Cesium采用@cesium/engine、@cesium/widgets等独立包
   - 本项目应将前端模块分离：cesium-viewer、ai-chat、config-panel

2. **关注点分离**
   - FastAPI：路由、数据模型、业务逻辑分离
   - 本项目：API层、Service层、Model层清晰划分

3. **生命周期管理**
   - React组件需要proper cleanup
   - Cesium Viewer需要在组件卸载时destroy

### 22.2 性能优化

1. **按需渲染**
   - Cesium的requestRenderMode
   - React的React.memo、useMemo、useCallback

2. **异步处理**
   - FastAPI的async/await
   - 避免阻塞事件循环

3. **连接池管理**
   - SQLAlchemy的连接池配置
   - 合理设置pool_size和max_overflow

### 22.3 数据库设计

1. **Schema管理**
   - 使用Alembic进行版本化迁移
   - 避免直接在生产环境执行DDL

2. **查询优化**
   - 使用select_related/joinedload避免N+1
   - 合理使用索引（复合索引、覆盖索引）

3. **数据验证**
   - Pydantic提供强大的数据验证
   - 在ORM层和应用层双重验证

### 22.4 测试策略

1. **测试金字塔**
   - 60%单元测试（pytest、vitest）
   - 30%集成测试（API测试）
   - 10%E2E测试（Playwright）

2. **测试隔离**
   - 使用测试数据库
   - 每个测试前后清理数据

3. **覆盖率目标**
   - 核心业务逻辑：>90%
   - 整体代码：>80%

### 22.5 安全实践

1. **依赖注入**
   - FastAPI的Depends系统
   - 便于测试和权限控制

2. **异常处理**
   - 全局异常处理器
   - 统一错误响应格式

3. **日志记录**
   - 结构化日志
   - 敏感信息脱敏

### 22.6 开发体验

1. **类型安全**
   - TypeScript（前端）
   - Python Type Hints（后端）
   - MyPy类型检查

2. **代码质量**
   - ESLint、Prettier（前端）
   - Black、isort、flake8（后端）
   - Pre-commit hooks

3. **文档化**
   - API自动文档（FastAPI）
   - 代码注释
   - 设计文档

---

**文档结束**

> 本设计文档基于免费技术方案，参考了Cesium、FastAPI、React、SQLAlchemy等主流开源项目的最佳实践，确保项目可完全在零成本的前提下实施和运营，同时保证代码质量、性能和安全性。
